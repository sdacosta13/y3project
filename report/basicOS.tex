\subsection{Layout and structuring}
As mentioned in Chapter \ref{motivations}, one of the main problems I had in COMP22712 was keeping my code organised as I was learning the intricacies of ARM while trying to write code. Now armed with a little more experience, I wanted to ensure that my code was kept organised from the start. I decided the best way to start would be to organise my main file \verb|os.s|. This file in my work for COMP22712 had been quite disorganised. It had a lot of the handlers required in the same file, which I felt was not great practise as it does not allow for a separation of concerns. I organised this file by making use of the INCLUDE mnemonic. This mnemonic is similar in concept to an import command in Java or Python except it differs in its exact implementation. INCLUDE in ARM has the effect of moving the code from the specified file to the location of the INCLUDE command. This is close to how C implements include. % reference here?
This separation of concern leaves the file \verb|os.s| as a file which starts as a vector table, containing branches to each of the handlers, followed by a long list of include statements defining where the handlers are kept and where prerequisite files are kept. The file also includes a halt loop which I can branch to if something happens which I cannot recover from. This really helped with debugging as I could use this loop to stop the processor after an error without it changing the state of any memory addresses. An issue I had encountered a lot in past course was that when I would run into something like a data abort or an undefined instruction, I would have nothing to stop the processor from overrunning the handler it would jump to. This would quite often make things hard to debug. Having the halt instruction allowed me to give the processor some control over halting itself.
\subsection{Self Imposed Conventions}
In order to keep my code organised and readable, I picked up a few conventions along the way which I tried to stick to. These were chosen with the intention of making my code easier to update in the long run as ARM is a difficult language to read. One of the conventions I stuck to best was to comment every procedure call under the label with a definition of which registers are used for input and output. This format provided me with an easy way to look up my method's and determine how to use them. Another benefit of this format is it distinguishes the branch label from other labels as an actual procedure call. Another convention I employed was the consistent pushing style of registers. When a procedure starts I always immediately push the LR, regardless of whether I need to. This is so that if I require a call to another procedure call, I don't need to remember to push the LR as it is already done. If I hadn't done this, then each time I needed to add a nested procedure call, if I forgot to push the LR then I would have an error on my hands which I would likely have to hand trace to debug. Similarly, when writing a new procedure, I would also push the registers I need to work in, and then immediately pop them, and then write the procedure in between. This meant that I could more closely mimic writing in a higher level language as I didn't have to think as much about the unusual parts of ARM. An example of these conventions is described below
\pagebreak
\begin{lstlisting}[
	style = myListingStyle,
	caption = {How all of the procedure calls started}
	]
	queue_index
	; IN  R0 - index to check
	; IN  R1 - Pointer to queue
	; OUT R2 - item to return or -1 if invalid
	PUSH {LR}
	PUSH {R0 - R1}
	PUSH {R3 - R12}
	
	; Actual procedure code goes here.	
	
	POP {R3 - R12}
	POP {R0 - R1}
	POP {LR}
	MOV PC, LR
	
\end{lstlisting}
I also utilised the \verb|EQU| directive often, in order to aid the readability of my code. For any constant or immediate value used (other than simple values such as -1, 0, 1, 2, 4) I would aim to name label them, and then only use the label. Another benefit of using this directive is that I could use them to do arithmetic to define how much space I would statically assign to blocks of memory. This was useful when designing the process control block, as I could scale how much memory I would need according to a single constant MAX\_THREADS. The ability to perform arithmetic operations with aliased names made scaling the program much easier. 
Finally, the last convention I imposed on myself was to write a commentary along some of the more technically challenging aspects of the code. For example the context switching procedure is the most complex thing I've written in ARM if not in all languages. So while writing this code I would start by writing a short comment describing the small subtask I wanted to complete, before actual writing the code to complete this subtask. This was quite a time-consuming process, as any changes which I needed to make usually meant that I had to re-write my comments. Due to this, I only employed this strategy when it was really necessary. I found this so helpful, that I would often describe the problems I needed to overcome for a specific subroutine in the subroutines' header. This acted as a cheaper way of documenting my code well without spending too much time on it. 
\subsection{Virtual LCD}
The installation of Komodo which I was developing for had a virtual LCD which I could manipulate from ARM. I wanted to provide some methods to the user which could be used to manipulate the screen. The screen appears in memory as a large frame buffer. This is in contrast to how the real world alternative does, as the real world alternative provides methods in which to output ASCII characters. As the virtual LCD does not contain these methods, I have to make them myself. I have done this before in COMP22712, however I felt I had an opportunity to improve upon this code. The past code I had written had some issues. For example the print character function did not actually work as intended. It had no ability to print control characters, which I felt was an oversight. My previous code also could only print in black and white which I felt was somewhere I could improve in. I decided that the best way to approach this task was with a top-down approach. Accordingly, I set about developing the print string function, which contained a call to print char, which I would develop later. This procedure was quite simple, as all it needed to do was loop through a string and call print char on each character, until it reached the \verb|NUL| character. 
Then I could develop the print char procedure. This procedure followed the following protocol listed in Listing \ref{lst:printchar_pseudo}
\begin{lstlisting}[
	style = myListingStyle,
	caption = {printchar psuedocode},
	label={lst:printchar_pseudo}	
	]
	if ( char is a control character ) {	
		update cursorposx according to char
		correct to ensure 0 <= cursorposx <= 40
		update cursorposy according to char
		correct to ensure 0 <= cursorposy <= 30
	} else if ( char is a letter ) {
		print the character
		update cursorposx
		update cursorposy
	} else {
		halt the processor
	}
\end{lstlisting}
The challenge of writing characters to the LCD essentially boils down to two main problems - Outputting a character template and keeping track of where the cursor is. Both problems are relatively trivial to solve, however how to write code to solve them efficiently is difficult.
\subsubsection{Keeping the cursor position consistent}
I solved this problem by first handling the control characters. I chose to determine which control character I was working with via a simple jump table. This has the benefit of allowing me to add more control characters very easily. Once I have jumped to the correct position I can then perform the correct operation. From here I then update the cursor position by performing the update and then checking and correcting the x and y coordinate against the bounds of the screen. As similar method is employed to correct the cursor after writing a character. Essentially every operation on the screen should leave the cursor in a position ready to print a new character. The characters I have supported are listed, and their effect are seen in Table \ref{controlcharacters}.
\begin{table}[h!]
	\centering
	\caption{Supported control characters.\label{controlcharacters}}
	\begin{tabular}{|c|c|}
		\hline
		Backspace & Delete a character left of the cursor \\
		Horizontal Tab & Move the cursor right \\
		Line Feed & Move the cursor down one line \\
		Vertical Tab & Move the cursor up one line \\
		Form feed & Clear the screen \\
		Carriage return & Move the cursor to the start of the next line \\
		\hline
	\end{tabular}
\end{table}
\subsubsection{Outputting a character}
To output a character I use a 7 x 8 bit font which was provided in COMP22712. It provides a font for ASCII characters 32 to 126. To determine the address of the font I have to subtract 32 from the character to normalise the character to the base of my font map. I then multiply by 7 bytes to determine the correct address. From here I have to read the loop over the 7 bytes as a 2d array essentially, with one dimension as the bytes and one dimension as the bits.
\subsection{The SVC Handler}
My SVC handler was one of the few pieces of code which I felt I could salvage from my work in COMP22712. The handler provides an organised way to interpret an SVC instruction and determine which operation to direct the processor to. It determines which program to jump to by reading the instruction in the link register. The handler then clears the opcode, leaving a 24 bit value which represents which program the SVC commands is referencing. It checks this code against the SVC\_MAX constant. This is a security measure to ensure that the SVC command cannot branch to any arbitrary code. In a single ADD instruction it then multiplies the SVC constant by 4 to get a words address and then adds it to the PC. The next instruction loads the address at this address to the program counter which causes the handler to jump to the correct position. This jump table method is an alternative to the most simple form of SVC handler which is a long string of 'switch style statements'. I chose the jump table over this method as I needed to support 12 methods, so a long chain of switch statement would not be particularly efficient. The operations I supported are as follows:

\begin{tabular}{cl cl}
	halt & (Halts the processor) \\
	printchar & (Prints a character to the virtual LCD) \\
	printstring & (Prints a NUL terminated string to the virtual LCD) \\
	timer & (Copies the timer into R0) \\
	button data  & (Gets the data from the virtual buttons \textit{deprecated}) \\
	setcursorposx & (Sets the horizontal position of the cursor) \\
	setcursorposy & (Sets the vertical position of the cursor) \\
	query\_keyboard & (Grabs the first pushed key from the virtual keyboard) \\
	query\_key & (Checks if a specific key is pushed) \\
	create\_thread & (Starts a thread from a specified address) \\
	end\_thread & (Kills the current thread) \\
	halt\_thread\_for\_IO & (Halts the thread until input occurs and then runs query\_keyboard) \\
\end{tabular} 

My SVC handler also includes a brief exit procedure which is always jumped to after completing an operation. This procedure just re-enables interrupts as I disable them during the SVC entry procedure to ensure that the operations execute atomically. 
\subsection{The IRQ Handler}

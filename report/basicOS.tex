\subsection{Layout and structuring}
As mentioned in Chapter \ref{motivations}, one of the main problems I had in COMP22712 was keeping my code organised as I was learning the intricacies of ARM while trying to write code. Now armed with a little more experience, I wanted to ensure that my code was kept organised from the start. I decided the best way to start would be to organise my main file \verb|os.s|. This file in my work for COMP22712 had been quite disorganised. It had a lot of the handlers required in the same file, which I felt was not great practice as it does not allow for a separation of concerns. I organised this file by making use of the INCLUDE mnemonic. This mnemonic is similar in concept to an import command in Java or Python except it differs in its exact implementation. The INCLUDE directive provided by my assembler has the effect of moving the code from the specified file to the location of the INCLUDE command. This is close to how C implements include. % reference here?

\begin{lstlisting}[
	style = myListingStyle,
	caption = {My main os.s file}
]
	ORIGIN &00000000
	B hard_reset                          ; +0   (00)
	B undefined_instruction_handler       ; +4   (04)
	B svc_handler                         ; +8   (08)
	B prefetch_abort_handler              ; +12  (0C)
	B data_abort_handler                  ; +16  (10)
	NOP                                   ; +20  (14)
	B IRQ_handler                         ; +24  (18)
	B FIQ_handler                         ; +28  (1C)

	halt ; should be jumped to, to stop the proccessor
	MOV R0, R0
	B halt

	; Import handlers
	INCLUDE handlers/reset_handler.s
	INCLUDE handlers/instruction_handler.s
 		...

	; Import definitions
	INCLUDE general/printchar.s
	INCLUDE general/printstring.s
  		...

	ALIGN
	INCLUDE general/usercode.s

\end{lstlisting}


My \verb|os.s| file also included a halt loop which I could jump to as a way of `halting` the processor as there is no way for the processor to halt itself
This really helped with debugging as I could use this loop to stop the processor after an error without it changing the state of any memory addresses. An issue I had encountered a lot in past course was that when I would run into something like a data abort or an undefined instruction, I would have nothing to stop the processor from overrunning the handler it would jump to. This would quite often make things hard to debug. Having the halt instruction allowed me to give the processor some control over halting itself.
\subsection{Self Imposed Conventions}
To keep my code organised and readable, I picked up a few conventions along the way which I tried to stick to. These were chosen with the intention of making my code easier to update in the long run as ARM is a difficult language to read. One of the conventions I stuck to best was to comment every procedure call under the label with a definition of which registers are used for input and output. This format provided me with an easy way to look up my method's and determine how to use them. Another benefit of this format is it distinguishes the branch label from other labels as an actual procedure call. Another convention I employed was the consistent pushing style of registers. When a procedure starts I always immediately push the LR, regardless of whether I need to. This is so that if I require a call to another procedure call, I don't need to remember to push the LR as it is already done. If I hadn't done this, then each time I needed to add a nested procedure call, if I forgot to push the LR then I would have an error on my hands which I would likely have to hand trace to debug. Similarly, when writing a new procedure, I would also push the registers I need to work in, and then immediately pop them, and then write the procedure in between. This meant that I could more closely mimic writing in a higher level language as I didn't have to think as much about the unusual parts of ARM. An example of these conventions is described below
\begin{lstlisting}[
	style = myListingStyle,
	caption = {How all of the procedure calls started}
	]
	queue_index
	; IN  R0 - index to check
	; IN  R1 - Pointer to queue
	; OUT R2 - item to return or -1 if invalid
	PUSH {R0 - R1, R3 - R12, LR}
	
	; Actual procedure code goes here.	
	
	PUSH {R0 - R1, R3 - R12, LR}^  ;return
	
\end{lstlisting}
I also utilised the \verb|EQU| directive often, in order to aid the readability of my code. For any constant or immediate value used (other than simple values such as -1, 0, 1, 2, 4) I would aim to name them, and then only use the label. Another benefit of using this directive is that I could use them to do arithmetic to define how much space I would statically assign to blocks of memory. This was useful when designing the process control block, as I could scale how much memory I would need according to a single constant MAX\_THREADS. The ability to perform arithmetic operations with aliased names made scaling the program much easier. 
Finally, the last convention I imposed on myself was to write a commentary along some of the more technically challenging aspects of the code. For example the context switching procedure is the most complex thing I've written in ARM if not in all languages. So while writing this code I would start by writing a short comment describing the small subtask I wanted to complete, before  writing the code to complete this subtask. This was quite a time-consuming process, as any changes which I needed to make usually meant that I had to re-write my comments. Due to this, I only employed this strategy when it was really necessary. I found this so helpful, that I would often describe the problems I needed to overcome for a specific subroutine in the subroutines' header. This acted as a cheaper way of documenting my code well without spending too much time on it. 
\subsection{Virtual Screen}
The installation of Komodo which I was developing for had a virtual screen (as described in figure \ref{fig:LCDMem}) which I could manipulate. I wanted to provide some methods to the user which could be used to manipulate the screen. The screen appears in memory as a large frame buffer. This is in contrast to how most real world alternatives would present themselves. For example, if you were to use a Hitachi HD44780 \cite{datasheet}, you would find that it presents its self as a more `intelligent` controllable device. Rather than writing directly to the frame-buffer to write characters, it is far more efficient to give it commands to write the characters, which it can then carry out itself. As the virtual screen does not contain these methods, I have to make them myself. I have done this before in COMP22712, however I felt I had an opportunity to improve upon this code. My previous code also could only print in black and white which I felt was somewhere I could improve in. My new functions would take a pointer to a string as a parameter as well as a pointer to 6 bytes defining the RGB colour of the background and text colour. 


The procedure I developed to print a single character is shown in listing \ref{lst:printchar_pseudo}. This procedure would be called for every character in a string in order to provide the print string function. 
\begin{lstlisting}[
	style = myListingStyle,
	caption = {printchar pseudocode},
	label={lst:printchar_pseudo}	
	]
	if ( char is a control character ) {	
		update cursorposx according to char
		correct to ensure 0 <= cursorposx <= 40
		update cursorposy according to char
		correct to ensure 0 <= cursorposy <= 30
	} else if ( char is a letter ) {
		print the character
		update cursorposx
		update cursorposy
	} else {
		halt the processor
	}
\end{lstlisting}
The challenge of writing characters to the LCD essentially boils down to two main problems - Outputting a character template and keeping track of where the cursor is. Both problems are relatively trivial to solve, however how to write code to solve them efficiently is difficult.
\subsubsection{Keeping the cursor position consistent}
I solved this problem by first handling the control characters. These characters are the ASCII characters used to control the movement of the cursor. I chose to determine which control character I was working with via a simple jump table. This has the benefit of allowing me to add more control characters easily. Once I have jumped to the correct position I can then perform the correct operation. From here I then update the cursor position by performing the update and then checking and correcting the x and y coordinate against the bounds of the screen. A similar method is employed to correct the cursor after writing a character. Essentially every operation on the screen should leave the cursor in a position ready to print a new character. The characters I have supported are listed, and their effect is seen in Table \ref{controlcharacters}.
\begin{table}[H]
	\centering
	\caption{Supported control characters.\label{controlcharacters}}
	\begin{tabular}{|c|c|}
		\hline
		Backspace & Delete a character left of the cursor \\
		Horizontal Tab & Move the cursor right \\
		Line Feed & Move the cursor down one line \\
		Vertical Tab & Move the cursor up one line \\
		Form feed & Clear the screen \\
		Carriage return & Move the cursor to the start of the next line \\
		\hline
	\end{tabular}
\end{table}
\subsubsection{Outputting a character}
To output a character I use a 7 x 8 pixel font which was provided in COMP22712. It provides a font for ASCII characters 32 to 126. To determine the address of the font I have to subtract 32 from the character to normalise the character to the base of my font map. I then multiply by 7 bytes to determine the correct address. From here I have to read the loop over the 7 bytes as a 2d array essentially, with one dimension as the bytes and one dimension as the bits as demonstrated in figure \ref{fig:fontexample}.


\begin{figure}[H]
	\begin{subfigure}{0.5\linewidth}
		\includegraphics[width=\linewidth]{figures/font.png}
	\end{subfigure}
	\begin{subfigure}{0.5\linewidth}
		\includegraphics[width=\linewidth]{figures/fontmap.png}
	\end{subfigure}
	

	\caption{The font set-up in memory}
	\label{fig:fontexample}
\end{figure} 




\subsection{The SVC Handler}
My SVC handler was one of the few pieces of code which I felt I could salvage from my work in COMP22712. The handler provides an organised way to interpret an SVC instruction and determine which operation to direct the processor to. It determines which program to jump to by reading the instruction in the link register. The handler then clears the opcode, leaving a 24 bit value which represents which program the SVC commands is referencing. It checks this code against the SVC\_MAX constant. This is a security measure to ensure that the SVC command cannot branch to any arbitrary code. In a single ADD instruction it then multiplies the SVC constant by 4 to get a words address and then adds it to the PC. The next instruction loads the address at this address to the program counter which causes the handler to jump to the correct position. This jump table method is an alternative to the most simple form of SVC handler which is a long string of 'switch style statements'. I chose the jump table over this method as I needed to support 12 methods, so a long chain of switch statement would not be particularly efficient. The operations I supported are as follows:

\begin{tabular}{cl cl}
	halt & (Halts the processor) \\
	printchar & (Prints a character to the virtual LCD) \\
	printstring & (Prints a NUL terminated string to the virtual LCD) \\
	timer & (Copies the timer into R0) \\
	button data  & (Gets the data from the virtual buttons \textit{deprecated}) \\
	setcursorposx & (Sets the horizontal position of the cursor) \\
	setcursorposy & (Sets the vertical position of the cursor) \\
	query\_keyboard & (Grabs the first pushed key from the virtual keyboard) \\
	query\_key & (Checks if a specific key is pushed) \\
	create\_thread & (Starts a thread from a specified address) \\
	end\_thread & (Kills the current thread) \\
	halt\_thread\_for\_IO & (Halts the thread until input occurs and then runs query\_keyboard) \\
\end{tabular} 

My SVC handler also includes a brief exit procedure which is always jumped to after completing an operation. This procedure just re-enables interrupts as the processor disables them during the SVC entry procedure to ensure that the operations execute atomically. 
\subsection{The IRQ Handler}

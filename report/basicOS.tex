\subsection{Layout and structuring}
As mentioned in chapter \ref{motivations}, one of the main problems I had in COMP22712 was keeping my code organised as I was learning the intricacies of ARM while trying to write code. Now armed with a little more experience, I wanted to ensure that my code was kept organised from the start. I decided the best way to start would be to organise my main file 'os.s'. This file in my work for COMP22712 had been quite disorganised. It had a lot of the handlers required in the same file, which I felt was not great practise as it does not allow for a separation of concerns. I organised this file by making use of the INCLUDE mnemonic. This mnemonic is similar in concept to an import command in Java or Python except it differs in its exact implementation. INCLUDE in ARM has the effect of moving the code from the specified file to the location of the INCLUDE command. This is close to how C implements include. % reference here?
This separation of concern leaves the file 'os.s' as a file which starts as a vector table, containing branches to each of the handlers, followed by a long list of include statements defining where the handlers are kept and where prerequisite files are kept. The file also includes a halt loop which I can branch to if something happens which I cannot recover from. This really helped with debugging as I could use this loop to stop the processor after an error without it changing the state of any memory addresses. An issue I had encountered a lot in past course was that when I would run into something like a data abort or a undefined instruction, I would have nothing to stop the processor from overrunning the handler it would jump to. This would quite often make things hard to debug. Having the halt instruction allowed me to give the processor some control over halting itself.
\subsection{Self Imposed Conventions}
In order to keep my code organised and readable, I picked up a few convention along the way which I tried to stick to. These were chosen with the intention of making my code easier to update in the long run as ARM is a difficult language to read. One of the conventions I stuck to best was to comment every procedure call under the label with a definition of which registers are used for input and output. This format provided me with a easy way to lookup my method's and determine how to use them. Another benefit of this format is it distinguishes the branch label from other labels as an actual procedure call. Another convention I employed was the consistent pushing style of registers. When a procedure starts I always immediately push the LR, regardless of whether I need to. This is so that if I require a call to another procedure call, I don't need to remember to push the LR as it is already done. If I hadn't done this, then each time I needed to add a nested procedure call, if I forgot to push the LR then I would have an error on my hands which I would likely have to hand trace to debug. Similarly, when writing a new procedure, I would also push the registers I need to work in, and then immediately pop them, and then write the procedure in between. This meant that I could more closely mimic writing in a higher level language as I didn't have to think as much about the unusual parts of ARM. An example of these convention is described below
\pagebreak
\begin{lstlisting}[
	style = myListingStyle,
	caption = {How all of the procedure calls started}
	]
	queue_index
	; IN  R0 - index to check
	; IN  R1 - Pointer to queue
	; OUT R2 - item to return or -1 if invalid
	PUSH {LR}
	PUSH {R0 - R1}
	PUSH {R3 - R12}
	
	; Actual procedure code goes here.	
	
	POP {R3 - R12}
	POP {R0 - R1}
	POP {LR}
	MOV PC, LR
	
\end{lstlisting}
I also utilised the EQU directive often, in order to aid the readability of my code. For any constant or immediate value used (other than simple values such as -1, 0, 1, 2, 4) I would aim to name label them, and then only use the label. Another benefit of using this directive is that I could use them to do arithmetic to define how much space I would statically assign to blocks of memory. This was useful when designing the process control block, as I could scale how much memory I would need according to a single constant MAX\_THREADS. The ability do perform arithmetic operations with aliased names made making the program scalable so much more easy. 
Finally, the last convention I imposed on myself was to write a commentary along some of the more technically challenging aspects of the code. For example the context switching procedure is the most complex thing i've written in ARM if not in all languages. So while writing this code I would start by writing a short comment describing the small subtask I wanted to complete, before actual writing the code to complete this subtask. This was quite a time consuming process, as any changes which I needed to make usually meant that I had to re-write my comments. Due to this, I only employed this strategy when it was really necessary. I found this so helpful, that I would often describe the problems I needed to overcome for a specific subroutine in the subroutines header. This acted as a cheaper way of documenting my code well without spending too much time on it. 
\subsection{Virtual IO}
\subsection{The SVC Handler}
My SVC handler was one of the few pieces of code which I felt I could salvage from my work in COMP22712. It provides an organised way to interpret an SVC instruction and determine which operation to direct the processor to. It determines which program to jump to by reading the instruction in the link register. It then clears the opcode, leaving a 24 bit value which represents which program the SVC commands is referencing. It checks this code against the SVC\_MAX constant. This is a security measure to ensure that the SVC command cannot branch to any arbitrary code. In a single ADD instruction it then multiplies the SVC constant by 4 to get a words address and then adds it to the PC. The next instruction loads the address at this address to the program counter which causes the handler to jump to the correct position. This jump table method is an alternative to the most simple form of SVC handler which is a long string of 'switch style statements'. I chose the jump table over this method as I needed to support 12 methods, so a long chain of switch statement would not be particularly efficient. The operations I supported are as follows:

\begin{tabular}{cl cl}
	halt & (Halts the processor) \\
	printchar & (Prints a character to the virtual LCD) \\
	printstring & (Prints a NUL terminated string to the virtual LCD) \\
	timer & (Copies the timer into R0) \\
	button data  & (Gets the data from the virtual buttons \textit{deprecated}) \\
	setcursorposx & (Sets the horizontal position of the cursor) \\
	setcursorposy & (Sets the vertical position of the cursor) \\
	query\_keyboard & (Grabs the first pushed key from the virtual keyboard) \\
	query\_key & (Checks if a specific key is pushed) \\
	create\_thread & (Starts a thread from a specified address) \\
	end\_thread & (Kills the current thread) \\
	halt\_thread\_for\_IO & (Halts the thread until input occurs and then runs query\_keyboard) \\
\end{tabular} 

My SVC handler also includes a brief exit procedure which is always jumped to after completing an operation. This procedure just re-enables interrupts as I disable them during the SVC entry procedure to ensure that the operations execute atomically. 
\subsection{The IRQ Handler}

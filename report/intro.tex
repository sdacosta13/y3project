Operating Systems\cite{os} are used everywhere in the modern day. Nowadays, even when performing trivial actions like ordering take-out food or checking out at a supermarket, people engage with an operating system. These systems are so ubiquitous that people outside of the field of computer science may not even realise that they are interacting with one. If you were  to ask these people what an operating system was, they would probably give you an answer like Windows \cite{windows}, MacOS \cite{apple} or Linux \cite{linux}. In reality the definition of an Operating System extends further beyond the bounds of operating systems for personal computers. At its core an Operating System is the low-level software which supports the basic functions of a computer, tasks such as scheduling and controlling IO devices. Understanding the role Operating Systems for modern computers should be important for high level programmers as the code they write will always be subject to the Operating System's management (of the computer). ARM provides a good platform for understanding Operating Systems as it allows an experience of a system before any software is present. This completely `clean slate' to build on can build a programmer's understanding of an Operating System as, before any application code can be written, the programmer has to tackle at least some of the problems. 

\subsection{Project Goals}
At the start of the project I derived three main goals.
\subsubsection{Objective 1}
\label{obj1}
% Support basic functions
The first goal was to support the basic function of an Operating System. This includes providing an environment for user code to be run in and the tools required for a user to access privileged components of the system. This includes: providing a Supervisor Call Handler (SVC) to service requests such as calls to graphical output, providing a reset handler to reset relevant parts of the memory to a workable state and providing access to input and output devices. 
\subsubsection{Objective 2}
\label{obj2}
% Handle realistic Input
The second goal was to design, develop and interface a virtual keyboard with the system. This keyboard should, at a minimum, provide the ability to convey keystrokes to the system. A more sophisticated implementation would be able to recognise combinations of keystrokes and report the use of control keys being pressed to move a cursor. I propose to use a virtual keyboard as I intend the emulate an ARM processor rather than develop on a physical one.
\subsubsection{Objective 3}
\label{obj3}
% Develop a Process Management System
The third goal was the development and implementation of a thread management system for my processor. This differs slightly from the implementation of process management \cite{process} on modern operating systems as my thread management system will operate in a single memory space. Typical process management systems operate in separate virtual memory spaces. While it may be possible to implement this on an ARM chip, the lack of support on the particular chip I have would make this a hard task to accomplish with only software. Therefore, I opt to develop threads rather than processes. In addition to this management system, I also need to develop the required methods to give the user access to use the management system as a tool. These methods include the ability to create and end threads. Further implementations could include the ability to enable smooth communications between threads. 
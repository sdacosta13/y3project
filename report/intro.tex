Operating Systems are used everywhere in the modern day. Nowadays, even when performing trivial actions like ordering take-out food or checking out at a supermarket, people engage with an operating system. These systems are so ubiquitous that people outside of the field of computer science may not even realise that they are interacting with one. If you were  to ask these people what an operating system was, they would probably give you an answer like, Windows \cite{windows}, MacOS \cite{apple} or Linux \cite{linux}. In reality the definition of an Operating System extends further beyond the bounds of OS's for personal computers. At its core an Operating System is the low-level software which supports the basic functions of a computer, tasks such as scheduling, and controlling IO devices. Understanding the role Operating Systems play for modern computers should be important for high level programmers as the code they write will always be subject to the Operating Systems management of the computer. ARM provides a good platform for understanding Operating Systems as they allow an experience of a system before any software is present. This completely clean slate to build on can build a programmers understanding of an Operating System as before any application code can be written, the programmer has to tackle at least some of the problems. 

\subsection{Project Goals}
At the start of the project I derived three main goals.
\subsubsection{Objective 1}
\label{obj1}
% Support basic functions
The first goal is to support the basic function of a computer. This includes providing an environment for user code to be run in and the tools required for a user access privileged components of the chip. This includes: Providing an Supervisor Call handler (SVC) to service calls to a graphical output; Providing a reset handler to reset relevant parts of the memory to a workable state; Providing access to input devices. 
\subsubsection{Objective 2}
\label{obj2}
% Handle realistic Input
The second goal is to design, develop and interface a virtual keyboard with the system. This keyboard should at a minimum provide the ability to convey keystrokes to the system. A more sophisticated implementation would be able to recognise combinations of keystrokes and report the use of control keys being pressed to move the cursor. I propose to use a virtual keyboard as I intend the emulate an arm processor rather than develop on a real one. 
\subsubsection{Objective 3}
\label{obj3}
% Develop a Process Management System
The third goal is the development and implementation of a thread management system for my processor. This would differ slightly from the implementation of process management on modern operating systems as my thread management system will operate in a single memory space. Typical process management systems operate in separate virtual memory spaces. While it may be possible to implement this on an arm chip, the lack of hardware support on the particular chip I have would make this an incredibly hard task to accomplish with only software. Therefore, I opt to develop threads rather than processes. In addition to this management system, I am also required to develop the required methods to give the user access to use the management system as a tool. These methods would include the ability to create and end threads. Further implementations could include the ability to enable smooth communications between threads. 